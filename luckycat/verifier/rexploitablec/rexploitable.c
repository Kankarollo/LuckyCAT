#include "rexploitable.h"

typedef struct
{
  const char* host;
  int port;
  const char* queue_name;
  const char* gdbserver;
  const char* gdbserver_address;
  const char* target;
  const char* argv;
  const char* temporary_file_template;
  int timeout;
  int log_level;
} configuration;

typedef struct
{
  char* crash_path;
  BSJ* job;
  char* decoded_crash;
  int decoded_crash_size;
  char* crash_name;
} crash;

configuration config;

int timeout = 0;
int child_done = 0;

void child_handler(int sig)
{
    child_done = 1;
}

void alarm_handler(int sig)
{
    timeout = 1;
}

static int config_handler(void* user, const char* section, const char* name,
                   const char* value)
{
    configuration* pconfig = (configuration*)user;

    #define MATCH(s, n) strcmp(section, s) == 0 && strcmp(name, n) == 0
    if (MATCH("queue", "port")) {
        pconfig->port = atoi(value);
    } else if (MATCH("queue", "host")) {
        pconfig->host = strdup(value);
    } else if (MATCH("queue", "name")) {
        pconfig->queue_name = strdup(value);
    } else if (MATCH("target", "target")) {
        pconfig->target = strdup(value);
    } else if (MATCH("target", "gdbserver")) {
        pconfig->gdbserver = strdup(value);
    } else if (MATCH("target", "gdbserver_address")) {
        pconfig->gdbserver_address = strdup(value);
    } else if (MATCH("target", "temporary_file_template")) {
        pconfig->temporary_file_template = strdup(value);
    } else if (MATCH("target", "timeout")) {
        pconfig->timeout = atoi(value);
    } else if (MATCH("general", "log_level")) {
        pconfig->log_level = atoi(value);
    } else {
        return 0;
    }
    return 1;
}

int connect_to_beanstalk(){
  int a,b,c;
  bs_version(&a, &b, &c);
  log_debug("beanstalk-client version %d.%d.%d", a,b,c);
  log_debug("connecting to queue %s at %s:%d", config.queue_name, config.host, config.port);

  int socket = bs_connect(config.host, config.port);
  if(socket == BS_STATUS_FAIL){
    log_error("could not connect to beanstalk queue");
    exit(1);
  }

  log_debug("connected to queue.");

  return socket;
}

void write_job_data_to_file(crash* current_crash){
  char* path = strdup(config.temporary_file_template);

  FILE* out = fopen(path, "w");
  if(out == NULL){
    log_error("could not create file in fixed path. Not writable?");
    exit(1);
  }

  fwrite(current_crash->decoded_crash, 1, current_crash->decoded_crash_size, out);

  current_crash->crash_path = path;

  log_debug("created temporary file %s", path);
  fclose(out);
}

crash* get_crash(int queue){
  if (bs_use(queue, config.queue_name) != BS_STATUS_OK) {
    log_error("could not use tube %s", config.queue_name);
    exit(1);
  }

  if (bs_watch(queue, config.queue_name) != BS_STATUS_OK){
    log_error("could not watch tube %s", config.queue_name);
    exit(1);
  }

  BSJ *job;
   log_debug("requesting next job.");
    if(bs_reserve(queue, &job) != BS_STATUS_OK) {
      log_error("could not reserve job. aborting...");
      exit(1);
    }

    if (job == NULL){
      log_error("invalid job pointer. aborting...");
      exit(1);
    }

  crash* current_crash = malloc(sizeof(crash));
  current_crash->job = job;
  log_debug("reserve job id: %"PRId64" size: %lu", current_crash->job->id, current_crash->job->size);

  char* copy = strdup(current_crash->job->data);
  char* sep = strchr(copy, ',');
  *sep = 0;
  char* sep2 = strchr(sep+1, ',');
  *sep2 = 0;
  current_crash->crash_name = strdup(sep+1);

  current_crash->decoded_crash = b64_decode(copy, strlen(copy));
  current_crash->decoded_crash_size = sep - copy;
  log_debug("decoded crash size is %d", current_crash->decoded_crash_size);

  free(copy);

  return current_crash;
}

void exec_crash(crash* tc){
  pid_t pid = fork();

  if (pid == -1) {
      log_error("fork failed");
      exit(1);
  } else if (pid == 0) {
    // in parent
     char** argv = malloc(sizeof (char*) * 4);
     char* gdbserver = strdup(config.gdbserver);
     char* target = strdup(config.target);
     char* gdbserver_address = strdup(config.gdbserver_address);
     argv[0] = gdbserver;
     argv[1] = gdbserver_address;
     argv[2] = target;
     argv[3] = 0;
     log_debug("executing %s %s %s", gdbserver, gdbserver_address, target);

     execv(gdbserver, argv);

     log_error("[child] exec failed");
     free(argv);
     free(gdbserver);
     free(gdbserver_address);
     free(target);

     _exit(1);
  }
  else{
    // in child
    signal(SIGALRM, alarm_handler);
    signal(SIGCHLD, child_handler);

    alarm(config.timeout);  // install an alarm to be fired after TIME_LIMIT
    pause();

    int status;
    int result = waitpid(pid, &status, WNOHANG);

    if (timeout) {
      log_debug("alarm triggered");

      if (result == 0) {
	// child still running, so kill it
	log_warn("killing child\n");
	kill(pid, 9);
	wait(NULL);
      } else {
	log_warn("alarm triggered, but child finished normally");
      }
    } else if (child_done) {
      log_debug("child finished normally");
      wait(NULL);
    }
    log_debug("target exited with return code %d", status);
  }
}

void free_crash(int queue, crash* tc){
   log_debug("delete job id: %"PRId64"", tc->job->id);
   if (bs_delete(queue, tc->job->id) != BS_STATUS_OK){
     log_error("could not release job. aborting...");
     exit(1);
   }

  if(remove(tc->crash_path) == -1){
    log_error("could not delete test case temporary file %s", tc->crash_path);
    exit(1);
  }

  free(tc->decoded_crash);
  free(tc->crash_path);
  free(tc->crash_name);
  bs_free_job(tc->job);
  free(tc);
}

void do_verification(int queue){
        log_info("Starting verification...");
        while(1){

                crash* current_crash = get_crash(queue);
                write_job_data_to_file(current_crash);
                exec_crash(current_crash);
                free_crash(queue, current_crash);
        }

}

int main(int argc, char *argv[argc])
{
  if (ini_parse("config.ini", config_handler, &config) < 0) {
    log_error("can not load 'config.ini'");
    return 1;
  }

  log_set_level(config.log_level);

  int queue = connect_to_beanstalk();

  do_verification(queue);

  bs_disconnect(queue);
  return 0;
}
